# ソースコードの構成
<ul>
    <li>.github/workflows/test.yml</li>
    Github Actionで自動テストを行うための設定ファイル
    <li>./src/main.py</li>
    エンドポイントや，リクエスト・レスポンスに関する処理を記述したファイル
    <li>./src/fibonacci.py</li>
    フィボナッチ数列のn番目の項を求める処理を記述したファイル
    <li>./src/test.py</li>
    fibonacci.pyのユニットテストなどを記述したファイル
</ul>

# ソフトウェア構成
### 言語
- Python
### フレームワーク
- Flask
### インフラ
- Render（mainブランチを更新すると自動でデプロイしてくれる）

# 概要
この技術課題のフィボナッチ数列のn番目の項を返すREST APIの開発ということで，大きく分けて難所は２つあると考えました．まず，nが大きくなると，すぐに64bit整数では扱えなくなるというところ．また，桁数が増えると，加算演算は桁数に比例して計算量が増えてしまうので，処理速度が遅くなってしまうという所だと考えました．

### 1. ｎが大きくなると，64bit整数では扱えなくなってしまう問題の対処
nが100の時で，おおよそ10の20乗ということから，long longなどの64bit整数でもオーバフローしてしまうため，メモリに応じて可変サイズで整数を表現できる多倍長整数が効果的であると考え，使用しようと決めました．また，多倍長数をデフォルトで採用しているPythonが多倍長整数の開発コスト・バグのない実装という点で言語として採用すべきだと考えました．

### 2. 桁数が増えると，処理速度が遅くなってしまう問題の対処
フィボナッチ数列の求め方として元から知っていたのは，トップダウン的にメモ化再帰を用いて求める方法と，ボトムアップ的に動的計画法を用いて求める方法です．これはどちらともO(N)で求めることができるのですが，ｎが大きくなってしまうと，値の桁数が増え，加算演算の計算量が桁数に比例して増えてしまうため，実質的にはO(N^2)のように，指数的に計算量が増えてしまうのではないかと考えました．これに対しては，少し調べたところ[1]，行列累乗を用いることで，行列のn乗をもとめることで，n項目を求めることができ，また行列のn乗は，繰り返し二乗法などを用いて，O(logN)にすることができるため，最終的にO(NlogN)まで減らすことができました．

# 工夫した点
- 計算量を考えて，高速にかつ，できるだけnが大きくなっても求めれることができるようにした点
- ユニットテストをローカルで手動でテストするだけではなく，Github Actionを用いてCIの自動化を行った点
- ソースコードを役割ごとでファイルを分け，凝集度は高く，結合度は低くなるようにした点
## 引用
[1] https://qiita.com/flour/items/9f8a20112f45f0ee5f71